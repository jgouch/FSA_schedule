#!/usr/bin/env python3
"""
build_month_schedule_v9_2_reporting.py

End-to-end month builder:
- Reads TimeOff.xlsx (monthly request sheet + Sales Ranking tab)
- Reads prior month schedule JSON for cross-month constraints
- Generates schedule for target month (primaries then BU)
- Exports:
  - schedule JSON (machine truth)
  - Excel calendar workbook (no template required) matching your geometry + colors
  - violations JSON (fairness/targets vs actual for PN/AN/W)
  - Excel "Violations" tab in the output workbook

LOCKED CALENDAR GEOMETRY (per John):
- Grid weeks: UP TO 6 (rows 3..50), each week is 8 rows tall
- Each day block: 3 columns x 8 rows
- Day number: top-right cell of block (col_end, week_start_row)
- Role mapping (R = week_start_row, cols = start/mid/end):
  PN label: (start, R+1), PN name: (mid, R+1)
  AN label: (start, R+2), AN name: (mid, R+2)
  W  label: (start, R+3), W  name: (mid, R+3)
  BU1 name: (mid, R+4)
  BU2 name: (mid, R+5)
  BU3 name: (mid, R+6)
  BU4 name (push-week Saturday only): (mid, R+7)

Color rules:
- Sundays (real dates): #FFF2CC
- Non-month blocks: #F2F2F2
- Other in-month days: no fill
Gridlines must be OFF.
"""

from __future__ import annotations

import argparse
import calendar
import json
import random
import re
from dataclasses import dataclass
from datetime import date, datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

import openpyxl
from openpyxl.styles import Alignment, Font, PatternFill
from openpyxl.utils import get_column_letter
from openpyxl.utils.datetime import from_excel


# ------------------------------
# Constants / settings
# ------------------------------
SUNDAY_FILL = "FFF2CC"
NONMONTH_FILL = "F2F2F2"

FONT_MAIN = Font(name="Calibri", size=11)
FONT_HEADER = Font(name="Calibri", size=18, bold=True)
ALIGN_CENTER = Alignment(horizontal="center", vertical="center", wrap_text=True)

GRID_WEEK_START_ROW = 3
WEEK_HEIGHT = 8
DAY_WIDTH = 3
SUN_START_COL = 2  # B

# Allow up to 6 weeks to support all calendar months
MAX_WEEKS = 6

ROLE_PRIMARY = ["PN", "AN", "W"]
ROLE_BUS = ["BU1", "BU2", "BU3", "BU4"]

# Park Lawn observed holidays (no roles on observed date)
OBSERVED_HOLIDAYS_BY_YEAR = {
    2026: {
        date(2026, 1, 1),   # New Year's Day
        date(2026, 5, 25),  # Memorial Day
        date(2026, 7, 3),   # Independence Day observed
        date(2026, 9, 7),   # Labor Day
        date(2026, 11, 26), # Thanksgiving
        date(2026, 12, 25), # Christmas
    }
}

# Default roster (display names used in Excel). You can expand later.
DEFAULT_ROSTER = ["Greg", "Mark", "Dawn", "Will", "CJ", "Kyle"]

# Seniority tie-break (only used if sales ranking missing)
SENIORITY_ORDER = ["Mark", "Dawn", "Will", "Kyle", "CJ", "Greg"]


# ------------------------------
# Helpers
# ------------------------------
def weekday_sun0(d: date) -> int:
    """Return weekday where Sunday=0..Saturday=6."""
    return (d.weekday() + 1) % 7

def is_sunday(d: date) -> bool:
    return weekday_sun0(d) == 0

def is_saturday(d: date) -> bool:
    return weekday_sun0(d) == 6

def is_weekday(d: date) -> bool:
    return d.weekday() < 5

def daterange(a: date, b: date) -> List[date]:
    out = []
    cur = a
    while cur <= b:
        out.append(cur)
        cur += timedelta(days=1)
    return out

def month_days(year: int, month: int) -> List[date]:
    n = calendar.monthrange(year, month)[1]
    return [date(year, month, d) for d in range(1, n + 1)]

def quarter_tag_for_month(year: int, month: int) -> str:
    q = (month - 1) // 3 + 1
    return f"{year}Q{q}"

def clamp_int(x, default=0) -> int:
    try:
        return int(x)
    except Exception:
        return default

def norm_name(x) -> str:
    return re.sub(r"\s+", " ", str(x).strip())

def parse_month_arg(s: str) -> Tuple[int, int]:
    m = re.match(r"^\s*(\d{4})-(\d{2})\s*$", s)
    if not m:
        raise ValueError("Month must be YYYY-MM, e.g. 2026-02")
    return int(m.group(1)), int(m.group(2))

def compute_observed_holidays_us(year: int) -> Set[date]:
    """Compute a small set of observed US holidays used in scheduling."""
    out: Set[date] = set()

    # New Year's Day
    out.add(date(year, 1, 1))

    # Memorial Day: last Monday in May
    d = date(year, 5, 31)
    while d.weekday() != 0:  # Monday
        d -= timedelta(days=1)
    out.add(d)

    # Independence Day observed: if July 4 is Sat -> Fri 3; if Sun -> Mon 5; else Jul 4
    july4 = date(year, 7, 4)
    if july4.weekday() == 5:
        out.add(date(year, 7, 3))
    elif july4.weekday() == 6:
        out.add(date(year, 7, 5))
    else:
        out.add(july4)

    # Labor Day: first Monday in September
    d = date(year, 9, 1)
    while d.weekday() != 0:
        d += timedelta(days=1)
    out.add(d)

    # Thanksgiving: fourth Thursday in November
    d = date(year, 11, 1)
    while d.weekday() != 3:  # Thursday
        d += timedelta(days=1)
    out.add(d + timedelta(days=21))

    # Christmas
    out.add(date(year, 12, 25))
    return out

def observed_holidays_for_year(year: int) -> Set[date]:
    return OBSERVED_HOLIDAYS_BY_YEAR.get(year, compute_observed_holidays_us(year))


# Pay periods (bi-weekly) repeat every 14 days from a known Sunday-start anchor.
PAY_PERIOD_ANCHOR_START = date(2026, 1, 25)

def generate_payperiods(anchor_start: date, start_date: date, end_date: date) -> List[Tuple[date, date]]:
    """Generate bi-weekly pay periods [start, end] inclusive using a Sunday-start anchor."""
    a = anchor_start
    while a > start_date:
        a -= timedelta(days=14)
    periods: List[Tuple[date, date]] = []
    cur = a
    while cur <= end_date:
        periods.append((cur, cur + timedelta(days=13)))
        cur += timedelta(days=14)
    return periods

def parse_excel_date(value) -> date:
    if isinstance(value, datetime):
        return value.date()
    if isinstance(value, date):
        return value
    if isinstance(value, (int, float)):
        try:
            return from_excel(value).date()
        except Exception as exc:
            raise ValueError(f"Unrecognized date format: {value!r}") from exc
    s = str(value).strip()
    for fmt in ("%Y-%m-%d", "%m/%d/%Y", "%m/%d/%y"):
        try:
            return datetime.strptime(s, fmt).date()
        except ValueError:
            continue
    raise ValueError(f"Unrecognized date format: {value!r}")


# ------------------------------
# Inputs from Excel (TimeOff.xlsx)
# ------------------------------
@dataclass
class TimeOffRule:
    name: str
    d: date
    hard: bool = True
    avoid_roles: Set[str] = None  # e.g., {"PN","AN"}

def load_timeoff_from_xlsx(xlsx_path: str, sheet_name: str) -> List[TimeOffRule]:
    wb = openpyxl.load_workbook(xlsx_path, data_only=True)
    if sheet_name not in wb.sheetnames:
        raise ValueError(f"Missing timeoff sheet '{sheet_name}' in {xlsx_path}")
    ws = wb[sheet_name]

    # Map headers
    headers: Dict[str, int] = {}
    for c in range(1, ws.max_column + 1):
        v = ws.cell(1, c).value
        if v is None:
            continue
        headers[str(v).strip().lower()] = c

    def col_optional(name: str) -> Optional[int]:
        return headers.get(name.lower(), None)

    def col_required(name: str) -> int:
        k = name.lower()
        if k not in headers:
            raise ValueError(
                f"TimeOff sheet missing column '{name}' (headers row 1). Found: {list(headers.keys())}"
            )
        return headers[k]

    c_name = col_required("name")
    c_date = col_optional("date")
    c_start = col_optional("start")
    c_end = col_optional("end")
    c_hard = col_optional("hard")
    c_avoid = col_optional("avoidroles")

    def parse_hard(v) -> bool:
        if v is None or str(v).strip() == "":
            return True
        s = str(v).strip().lower()
        return s in ("true", "1", "yes", "y")

    rules: List[TimeOffRule] = []
    for r in range(2, ws.max_row + 1):
        nv = ws.cell(r, c_name).value
        if nv is None or str(nv).strip() == "":
            continue
        name = norm_name(nv)

        dates: List[date] = []
        dv = ws.cell(r, c_date).value if c_date else None
        sv = ws.cell(r, c_start).value if c_start else None
        ev = ws.cell(r, c_end).value if c_end else None

        if dv not in (None, ""):
            dates = [parse_excel_date(dv)]
        elif sv not in (None, "") and ev not in (None, ""):
            start_d = parse_excel_date(sv)
            end_d = parse_excel_date(ev)
            if end_d < start_d:
                raise ValueError(f"End before Start at row {r}: {start_d} .. {end_d}")
            cur = start_d
            while cur <= end_d:
                dates.append(cur)
                cur += timedelta(days=1)
        else:
            continue

        hard = parse_hard(ws.cell(r, c_hard).value) if c_hard else True
        avoid_roles: Set[str] = set()
        if c_avoid:
            av = ws.cell(r, c_avoid).value
            if av:
                parts = [p.strip().upper() for p in str(av).split(",") if p.strip()]
                avoid_roles = set(parts)

        for dd in dates:
            rules.append(TimeOffRule(name=name, d=dd, hard=hard, avoid_roles=avoid_roles))

    return rules

def load_roster_from_sales_ranking(xlsx_path: str, sheet_name: str, year: int, month: int) -> List[str]:
    wb = openpyxl.load_workbook(xlsx_path, data_only=True)
    if sheet_name not in wb.sheetnames:
        raise ValueError(f"Missing sheet '{sheet_name}' in {xlsx_path}")
    ws = wb[sheet_name]

    target_period = quarter_tag_for_month(year, month)
    rows: Dict[str, List[str]] = {}
    for r in range(2, ws.max_row + 1):
        period = ws.cell(r, 1).value
        if not period:
            continue
        period = str(period).strip()
        ranks: List[str] = []
        for c in range(2, ws.max_column + 1):
            v = ws.cell(r, c).value
            if v is None or str(v).strip() == "":
                continue
            ranks.append(norm_name(v))
        if period and ranks:
            rows[period] = ranks

    def key(p: str):
        m = re.match(r"^\s*(\d{4})\s*Q([1-4])\s*$", p)
        if not m:
            return (-1, -1)
        return (int(m.group(1)), int(m.group(2)))

    if target_period in rows:
        return rows[target_period]
    candidates = sorted(rows.keys(), key=key)
    if candidates:
        return rows[candidates[-1]]
    return DEFAULT_ROSTER[:]

def load_roster_from_json(path: str) -> List[str]:
    data = json.loads(Path(path).read_text(encoding="utf-8"))
    if not isinstance(data, list) or not data:
        raise ValueError("Roster JSON must be a non-empty JSON array of names")
    return [norm_name(x) for x in data if str(x).strip()]

def load_payperiods_from_json(path: str) -> List[Tuple[date, date]]:
    data = json.loads(Path(path).read_text(encoding="utf-8"))
    if not isinstance(data, list) or not data:
        raise ValueError("Payperiods JSON must be a non-empty JSON array")
    out: List[Tuple[date, date]] = []
    for obj in data:
        if not isinstance(obj, dict) or "start" not in obj or "end" not in obj:
            raise ValueError("Each pay period must be an object with 'start' and 'end'")
        s = datetime.strptime(str(obj["start"]).strip(), "%Y-%m-%d").date()
        e = datetime.strptime(str(obj["end"]).strip(), "%Y-%m-%d").date()
        if e < s:
            raise ValueError(f"Pay period end before start: {s} .. {e}")
        out.append((s, e))
    out.sort(key=lambda t: t[0])
    return out

def load_sales_ranking_from_timeoff_xlsx(xlsx_path: str, sheet_name: str, year: int, month: int, roster_names: List[str]) -> List[str]:
    wb = openpyxl.load_workbook(xlsx_path, data_only=True)
    if sheet_name not in wb.sheetnames:
        raise ValueError(f"Missing sheet '{sheet_name}' in {xlsx_path}")
    ws = wb[sheet_name]

    target_period = quarter_tag_for_month(year, month)
    rows: Dict[str, List[str]] = {}
    for r in range(2, ws.max_row + 1):
        period = ws.cell(r, 1).value
        if not period:
            continue
        period = str(period).strip()
        ranks: List[str] = []
        for c in range(2, ws.max_column + 1):
            v = ws.cell(r, c).value
            if v is None or str(v).strip() == "":
                continue
            ranks.append(norm_name(v))
        if period and ranks:
            rows[period] = ranks

    def key(p: str):
        m = re.match(r"^\s*(\d{4})\s*Q([1-4])\s*$", p)
        if not m:
            return (-1, -1)
        return (int(m.group(1)), int(m.group(2)))

    if target_period in rows:
        order = rows[target_period]
    else:
        candidates = sorted(rows.keys(), key=key)
        order = rows[candidates[-1]] if candidates else []

    roster_set = set(roster_names)
    order_set = set(order)

    if not order:
        fallback = [n for n in SENIORITY_ORDER if n in roster_set]
        fallback += [n for n in roster_names if n not in fallback]
        return fallback

    missing = roster_set - order_set
    extra = order_set - roster_set
    if missing or extra:
        raise ValueError(
            f"Sales Ranking invalid for {target_period}. "
            f"Missing: {sorted(missing)} Extra/Unknown: {sorted(extra)} "
            f"Roster: {roster_names} Got: {order}"
        )
    return order


# ------------------------------
# Previous schedule JSON (carryover)
# ------------------------------
def load_schedule_json(path: str) -> Dict[str, Dict[str, str]]:
    data = json.loads(Path(path).read_text(encoding="utf-8"))
    if not isinstance(data, dict):
        raise ValueError("Schedule JSON must be a dict of ISO-date -> role dict")
    return data

def role_of(prev: Dict[str, Dict[str, str]], d: date, name: str) -> Optional[str]:
    roles = prev.get(d.isoformat(), {})
    for r, n in roles.items():
        if n == name:
            return r
    return None

def worked_prev(prev: Dict[str, Dict[str, str]], d: date, name: str) -> bool:
    roles = prev.get(d.isoformat(), {})
    return any(n == name for n in roles.values())


# ------------------------------
# Scheduling rules
# ------------------------------
def roles_required_for_day(d: date, push_week_days: Set[date], observed_holidays: Set[date]) -> List[str]:
    """
    REQUIRED roles only (Primaries).
    Note: We no longer include BUs here for the solver's hard pass.
    BUs are handled dynamically in the solver loop now.
    """
    if d in observed_holidays:
        return []
    if is_sunday(d):
        return ["PN"]
    req = ["PN", "AN"]
    if is_weekday(d):
        req.append("W")
    return req

def hours_for_role(d: date, role: str, observed_holidays: Set[date]) -> int:
    if d in observed_holidays:
        return 0
    if is_sunday(d) and role == "PN":
        return 5
    return 8

def week_start_sun(d: date) -> date:
    return d - timedelta(days=weekday_sun0(d))

def push_days_for_month(year: int, month: int) -> Set[date]:
    days = set()
    last_dom = calendar.monthrange(year, month)[1]
    last = date(year, month, last_dom)

    cur = last
    while cur.weekday() != 4:  # Friday
        cur -= timedelta(days=1)
    last_friday = cur
    last_monday = last_friday - timedelta(days=4)

    for i in range(5):
        days.add(last_monday + timedelta(days=i))

    sat = last_friday + timedelta(days=1)
    if sat.month == month:
        days.add(sat)
    return days


# ------------------------------
# Solver
# ------------------------------
@dataclass
class BuildConfig:
    year: int
    month: int
    roster: List[str]
    sales_order: List[str]  # highest -> lowest
    max_consecutive_days: int = 5
    lookback_days: int = 14
    rng_seed: int = 11

@dataclass
class Constraints:
    hard_off: Dict[date, Set[str]]
    avoid_roles: Dict[Tuple[date, str], Set[str]]  # (date, role)->names who avoid that role

def compile_constraints(timeoff: List[TimeOffRule]) -> Constraints:
    hard_off: Dict[date, Set[str]] = {}
    avoid_roles: Dict[Tuple[date, str], Set[str]] = {}
    for r in timeoff:
        if r.hard:
            hard_off.setdefault(r.d, set()).add(r.name)
        if r.avoid_roles:
            for role in r.avoid_roles:
                avoid_roles.setdefault((r.d, role.upper()), set()).add(r.name)
    return Constraints(hard_off=hard_off, avoid_roles=avoid_roles)

def _rotate_left(lst: List[str], k: int) -> List[str]:
    if not lst:
        return lst
    k = k % len(lst)
    return lst[k:] + lst[:k]

def compute_primary_targets(days: List[date], push_days: Set[date], roster: List[str], sales_order: List[str], observed_holidays: Set[date]) -> Dict[str, Dict[str, int]]:
    # Count opportunities for each primary role across the month
    opp = {"PN": 0, "AN": 0, "W": 0}
    for d in days:
        req = roles_required_for_day(d, push_days, observed_holidays)
        for role in ("PN", "AN", "W"):
            if role in req:
                opp[role] += 1

    n = len(roster)
    if n == 0:
        raise ValueError("Roster is empty")

    # Sales-based priority, but ensure it only contains roster members,
    # and append any missing roster members at the end.
    base_priority = [x for x in sales_order if x in roster] + [x for x in roster if x not in sales_order]

    targets: Dict[str, Dict[str, int]] = {role: {name: 0 for name in roster} for role in opp}

    # --- PN ---
    total_pn = opp["PN"]
    base_pn = total_pn // n
    rem_pn = total_pn % n
    for name in roster:
        targets["PN"][name] = base_pn
    pn_priority = base_priority  # no offset for PN
    for i in range(rem_pn):
        targets["PN"][pn_priority[i]] += 1

    # --- AN (offset by PN remainder) ---
    total_an = opp["AN"]
    base_an = total_an // n
    rem_an = total_an % n
    for name in roster:
        targets["AN"][name] = base_an
    an_priority = _rotate_left(base_priority, rem_pn)
    for i in range(rem_an):
        targets["AN"][an_priority[i]] += 1

    # --- W (offset by PN+AN remainders) ---
    total_w = opp["W"]
    base_w = total_w // n
    rem_w = total_w % n
    for name in roster:
        targets["W"][name] = base_w
    w_priority = _rotate_left(base_priority, (rem_pn + rem_an) % n)
    for i in range(rem_w):
        targets["W"][w_priority[i]] += 1

    return targets

def pick_week_index_for_day(year: int, month: int, day: int) -> Tuple[int, int, int, int]:
    """
    Returns (R, col_start, col_mid, col_end) for a date in this month using calendar math.
    """
    first = date(year, month, 1)
    offset = weekday_sun0(first)
    idx = offset + (day - 1)
    week_index = idx // 7
    dow = idx % 7

    if week_index < 0 or week_index >= MAX_WEEKS:
        raise ValueError(
            f"Date {year}-{month:02d}-{day:02d} falls in Week {week_index+1}, "
            f"but grid only supports {MAX_WEEKS} weeks. "
            "Please adjust the start date or calendar geometry."
        )

    R = GRID_WEEK_START_ROW + WEEK_HEIGHT * week_index
    col_start = SUN_START_COL + DAY_WIDTH * dow
    col_mid = col_start + 1
    col_end = col_start + 2
    return R, col_start, col_mid, col_end


def build_schedule(config: BuildConfig, prev_sched: Dict[str, Dict[str, str]], cons: Constraints, payperiods: Optional[List[Tuple[date, date]]] = None) -> Dict[str, Dict[str, str]]:
    rng = random.Random(config.rng_seed)
    year, month = config.year, config.month
    days = month_days(year, month)

    observed_holidays = observed_holidays_for_year(year)
    push_days = push_days_for_month(year, month)

    def week_contains_push(week_start: date) -> bool:
        return any((week_start + timedelta(days=i)) in push_days for i in range(7))

    def week_contains_holiday(week_start: date) -> bool:
        for i in range(7):
            dd = week_start + timedelta(days=i)
            if dd in observed_holidays_for_year(dd.year):
                return True
        return False

    def hours_for_any_role_on_day(dd: date, roles_map: Dict[str, Dict[str, str]], name: str) -> int:
        day_hours = 0
        roles = roles_map.get(dd.isoformat(), {})
        hols = observed_holidays if dd.year == year else observed_holidays_for_year(dd.year)
        for rr, nn in roles.items():
            if nn == name:
                day_hours = max(day_hours, hours_for_role(dd, rr, hols))
        return day_hours

    def week_hours(name: str, week_start: date) -> int:
        total = 0
        first_day = date(year, month, 1)
        for i in range(7):
            dd = week_start + timedelta(days=i)
            if dd.year == year and dd.month == month:
                total += hours_for_any_role_on_day(dd, schedule, name)
            elif dd < first_day:
                roles = prev_sched.get(dd.isoformat(), {})
                day_hours = 0
                hols = observed_holidays if dd.year == year else observed_holidays_for_year(dd.year)
                for rr, nn in roles.items():
                    if nn == name:
                        day_hours = max(day_hours, hours_for_role(dd, rr, hols))
                total += day_hours
        return total

    def week_days_worked(name: str, week_start: date) -> int:
        cnt = 0
        first_day = date(year, month, 1)
        last_day = date(year, month, calendar.monthrange(year, month)[1])
        for i in range(7):
            dd = week_start + timedelta(days=i)
            if dd > last_day:
                continue
            if dd.year == year and dd.month == month:
                if hours_for_any_role_on_day(dd, schedule, name) > 0:
                    cnt += 1
            elif dd < first_day:
                roles = prev_sched.get(dd.isoformat(), {})
                if any(nn == name for nn in roles.values()):
                    cnt += 1
        return cnt

    def would_exceed_week_cap(d: date, role: str, name: str) -> bool:
        ws = week_start_sun(d)
        if week_contains_push(ws):
            return False
        cur = week_hours(name, ws)
        add = hours_for_role(d, role, observed_holidays)
        return (cur + add) > 40

    def would_exceed_week_days_cap(d: date, name: str) -> bool:
        ws = week_start_sun(d)
        if week_contains_push(ws):
            return False
        if week_contains_holiday(ws):
            return False
        return (week_days_worked(name, ws) + 1) > 5

    def find_pay_period(d: date) -> Optional[Tuple[date, date]]:
        if not payperiods:
            return None
        for s, e in payperiods:
            if s <= d <= e:
                return (s, e)
        return None

    def pay_period_hours(name: str, pp: Tuple[date, date]) -> int:
        s, e = pp
        total = 0
        first_day = date(year, month, 1)
        dd = s
        while dd <= e:
            if dd.year == year and dd.month == month:
                total += hours_for_any_role_on_day(dd, schedule, name)
            elif dd < first_day:
                roles = prev_sched.get(dd.isoformat(), {})
                day_hours = 0
                hols = observed_holidays if dd.year == year else observed_holidays_for_year(dd.year)
                for rr, nn in roles.items():
                    if nn == name:
                        day_hours = max(day_hours, hours_for_role(dd, rr, hols))
                total += day_hours
            dd += timedelta(days=1)
        return total

    def would_exceed_payperiod_cap(d: date, role: str, name: str) -> bool:
        pp = find_pay_period(d)
        if not pp:
            return False
        if week_contains_push(week_start_sun(d)):
            return False
        cur = pay_period_hours(name, pp)
        add = hours_for_role(d, role, observed_holidays)
        return (cur + add) > 80

    targets = compute_primary_targets(days, push_days, config.roster, config.sales_order, observed_holidays)

    def last_role(name: str, d: date) -> Optional[str]:
        for k in range(1, config.lookback_days + 1):
            p = d - timedelta(days=k)
            if p.month == month:
                roles = schedule.get(p.isoformat(), {})
                for rr, nn in roles.items():
                    if nn == name:
                        return rr
            else:
                rr = role_of(prev_sched, p, name)
                if rr:
                    return rr
        return None

    def consecutive_streak(name: str, d: date) -> int:
        streak = 0
        for k in range(1, config.lookback_days + 1):
            p = d - timedelta(days=k)
            if p.month == month:
                worked = any(n == name for n in schedule.get(p.isoformat(), {}).values())
            else:
                worked = worked_prev(prev_sched, p, name)
            if worked:
                streak += 1
            else:
                break
        return streak

    roster = config.roster[:]
    sales_order = config.sales_order[:]

    def get_prev_sunday_assignee() -> Optional[str]:
        prev_dates = sorted(prev_sched.keys())
        for ds in reversed(prev_dates):
            dd = datetime.strptime(ds, "%Y-%m-%d").date()
            if is_sunday(dd):
                roles = prev_sched.get(ds, {})
                pn = roles.get("PN")
                if pn in roster:
                    return pn
                return None

    sunday_assignees: Dict[date, str] = {}
    prev_sun = get_prev_sunday_assignee()
    sundays = [d for d in days if is_sunday(d) and d not in observed_holidays]
    if sundays:
        start_idx = 0
        if prev_sun and prev_sun in roster:
            start_idx = (roster.index(prev_sun) + 1) % len(roster)
        for i, sd in enumerate(sundays):
            who = roster[(start_idx + i) % len(roster)]
            sunday_assignees[sd] = who

    schedule: Dict[str, Dict[str, str]] = {d.isoformat(): {} for d in days}

    def can_preassign(d: date, role: str, name: str) -> bool:
        if d in observed_holidays:
            return False
        if name in cons.hard_off.get(d, set()):
            return False
        if name in cons.avoid_roles.get((d, role), set()):
            return False
        if name in schedule[d.isoformat()].values():
            return False
        prev_role = last_role(name, d)
        if prev_role == role:
            return False
        if consecutive_streak(name, d) >= config.max_consecutive_days:
            return False
        if would_exceed_week_cap(d, role, name):
            return False
        if would_exceed_week_days_cap(d, name):
            return False
        if would_exceed_payperiod_cap(d, role, name):
            return False
        return True

    # Pre-assign Sundays PN and Saturday-before AN pair
    for sd, who0 in sunday_assignees.items():
        sat = sd - timedelta(days=1)
        need_sat_pair = (sat.month == month and sat not in observed_holidays)

        chosen = None
        for step in range(len(roster)):
            cand = roster[(roster.index(who0) + step) % len(roster)]
            if not can_preassign(sd, "PN", cand):
                continue
            if need_sat_pair and not can_preassign(sat, "AN", cand):
                continue
            chosen = cand
            break

        if chosen is None:
            raise RuntimeError(f"No valid Sunday PN assignee found for {sd.isoformat()} under current constraints")

        schedule[sd.isoformat()]["PN"] = chosen
        if need_sat_pair:
            schedule[sat.isoformat()]["AN"] = chosen

    # Primary role assignment order
    primary_slots: List[Tuple[date, str]] = []
    for d in days:
        req = roles_required_for_day(d, push_days, observed_holidays)
        for role in ("PN", "AN", "W"):
            if role in req:
                if role in schedule[d.isoformat()]:
                    continue
                primary_slots.append((d, role))

    pn_weekday_counts = {n: {i: 0 for i in range(7)} for n in roster}
    monday_pn_used = {n: 0 for n in roster}
    for d in days:
        roles = schedule[d.isoformat()]
        if "PN" in roles:
            pn_weekday_counts[roles["PN"]][weekday_sun0(d)] += 1
            if weekday_sun0(d) == 1:
                monday_pn_used[roles["PN"]] += 1

    role_counts = {r: {n: 0 for n in roster} for r in ("PN", "AN", "W")}
    for d in days:
        roles = schedule[d.isoformat()]
        for r in ("PN", "AN", "W"):
            if r in roles:
                role_counts[r][roles[r]] += 1

    def can_assign_primary(d: date, role: str, name: str) -> bool:
        if d in observed_holidays: return False
        if name in cons.hard_off.get(d, set()): return False
        if name in cons.avoid_roles.get((d, role), set()): return False
        if name in schedule[d.isoformat()].values(): return False
        prev_role = last_role(name, d)
        if prev_role == role: return False
        if consecutive_streak(name, d) >= config.max_consecutive_days: return False
        if would_exceed_week_cap(d, role, name): return False
        if would_exceed_week_days_cap(d, name): return False
        if would_exceed_payperiod_cap(d, role, name): return False
        return True

    def score_primary(d: date, role: str, name: str) -> float:
        s = 0.0
        t = targets.get(role, {}).get(name, 0)
        c = role_counts[role][name]
        s += (t - c) * 5.0

        if role == "PN":
            wd = weekday_sun0(d)
            s -= pn_weekday_counts[name][wd] * 3.0
            if wd == 1:
                s -= 50.0
            if monday_pn_used.get(name, 0) >= 1:
                s -= 250.0

        if name in sales_order:
            s += (len(sales_order) - sales_order.index(name)) * 0.05

        s += rng.random() * 0.25
        return s

    nodes = 0
    last_fail_slot: Tuple[date, str] = (days[0], "")

    def candidates_for(slot: Tuple[date, str]) -> List[str]:
        d, role = slot
        cands = [n for n in roster if can_assign_primary(d, role, n)]
        cands.sort(key=lambda n: score_primary(d, role, n), reverse=True)
        return cands

    def select_next_slot(slots_left: List[Tuple[date, str]]) -> Tuple[int, Tuple[date, str], List[str]]:
        best_i = -1
        best_slot = None
        best_cands = None
        best_len = 10**9
        for i, sl in enumerate(slots_left):
            cands = candidates_for(sl)
            L = len(cands)
            if L < best_len:
                best_len = L
                best_i = i
                best_slot = sl
                best_cands = cands
                if L <= 1:
                    break
        return best_i, best_slot, best_cands

    def assign_primary(d: date, role: str, name: str):
        schedule[d.isoformat()][role] = name
        role_counts[role][name] += 1
        if role == "PN":
            wd = weekday_sun0(d)
            pn_weekday_counts[name][wd] += 1
            if wd == 1:
                monday_pn_used[name] += 1

    def unassign_primary(d: date, role: str, name: str):
        del schedule[d.isoformat()][role]
        role_counts[role][name] -= 1
        if role == "PN":
            wd = weekday_sun0(d)
            pn_weekday_counts[name][wd] -= 1
            if wd == 1:
                monday_pn_used[name] -= 1

    def solve_primary(slots_left: List[Tuple[date, str]]) -> bool:
        nonlocal nodes, last_fail_slot
        if not slots_left:
            return True
        idx, slot, cands = select_next_slot(slots_left)
        if not cands:
            last_fail_slot = slot
            return False
        d, role = slot
        for name in cands:
            nodes += 1
            assign_primary(d, role, name)
            nxt = slots_left[:idx] + slots_left[idx+1:]
            if solve_primary(nxt):
                return True
            unassign_primary(d, role, name)
        return False

    ok = solve_primary(primary_slots)
    if not ok:
        raise RuntimeError(
            f"❌ Failed to assign primary roles. Stuck at {last_fail_slot[0].isoformat()} "
            f"role={last_fail_slot[1]} with 0 candidates."
        )

    # ---- BU backfill phase (Dynamic / Best Effort) ----
    bu_slots: List[Tuple[date, str]] = []
    for d in days:
        if d in observed_holidays:
            continue

        ideal_bu: List[str] = []
        if d in push_days:
            if is_saturday(d):
                ideal_bu = ["BU1", "BU2", "BU3", "BU4"]
            else:
                ideal_bu = ["BU1", "BU2", "BU3"]
        else:
            if weekday_sun0(d) == 1:  # Monday
                ideal_bu = ["BU1", "BU2", "BU3"]
            elif is_weekday(d):
                ideal_bu = ["BU1", "BU2"]
            else:
                ideal_bu = ["BU1", "BU2"]

        assigned_today = set(schedule[d.isoformat()].values())
        hard_off_today = cons.hard_off.get(d, set())
        available_people = [p for p in roster if p not in assigned_today and p not in hard_off_today]

        possible_roles: List[str] = []
        for role_name in ideal_bu:
            can_fill = False
            for p in available_people:
                if p not in cons.avoid_roles.get((d, role_name), set()):
                    can_fill = True
                    break
            if can_fill:
                possible_roles.append(role_name)

        count_to_fill = min(len(possible_roles), len(available_people))
        for i in range(count_to_fill):
            role_name = possible_roles[i]
            if role_name not in schedule[d.isoformat()]:
                bu_slots.append((d, role_name))

    def can_assign_bu(d: date, role: str, name: str) -> bool:
        if d in observed_holidays: return False
        if name in cons.hard_off.get(d, set()): return False
        if name in cons.avoid_roles.get((d, role), set()): return False
        if name in schedule[d.isoformat()].values(): return False
        prev_role = last_role(name, d)
        if prev_role == role: return False
        if consecutive_streak(name, d) >= config.max_consecutive_days: return False
        if would_exceed_week_cap(d, role, name): return False
        if would_exceed_week_days_cap(d, name): return False
        if would_exceed_payperiod_cap(d, role, name): return False
        return True

    def score_bu(d: date, role: str, name: str) -> float:
        return rng.random()

    nodes2 = 0
    last_fail_slot_bu: Tuple[date, str] = (days[0], "")

    def candidates_for_bu(slot: Tuple[date, str]) -> List[str]:
        d, role = slot
        cands = [n for n in roster if can_assign_bu(d, role, n)]
        cands.sort(key=lambda n: score_bu(d, role, n), reverse=True)
        return cands

    def select_next_slot_bu(slots_left: List[Tuple[date, str]]):
        best_i, best_slot, best_cands, best_len = -1, None, None, 10**9
        for i, sl in enumerate(slots_left):
            cands = candidates_for_bu(sl)
            L = len(cands)
            if L < best_len:
                best_len = L
                best_i, best_slot, best_cands = i, sl, cands
                if L <= 1:
                    break
        return best_i, best_slot, best_cands

    def solve_bu(slots_left: List[Tuple[date, str]]) -> bool:
        nonlocal nodes2, last_fail_slot_bu
        if not slots_left:
            return True
        idx, slot, cands = select_next_slot_bu(slots_left)
        if not cands:
            last_fail_slot_bu = slot
            return False
        d, role = slot
        for name in cands:
            nodes2 += 1
            schedule[d.isoformat()][role] = name
            nxt = slots_left[:idx] + slots_left[idx+1:]
            if solve_bu(nxt):
                return True
            del schedule[d.isoformat()][role]
        return False

    ok2 = solve_bu(bu_slots)
    if not ok2:
        raise RuntimeError(
            f"❌ Failed to assign BU roles. Stuck at {last_fail_slot_bu[0].isoformat()} "
            f"role={last_fail_slot_bu[1]} with 0 candidates."
        )

    return schedule


# ------------------------------
# Excel export (no template)
# ------------------------------
def export_schedule_to_excel(
    schedule: Dict[str, Dict[str, str]],
    year: int,
    month: int,
    out_xlsx: str,
    roster: List[str],
    observed_holidays: Set[date],
    prev_sched: Optional[Dict[str, Dict[str, str]]] = None,
    payperiods: Optional[List[Tuple[date, date]]] = None,
    title: Optional[str] = None,
    fairness_report: Optional[Dict] = None
):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = calendar.month_name[month]
    ws.sheet_view.showGridLines = False

    for col in range(2, 23):  # B..V
        ws.column_dimensions[get_column_letter(col)].width = 10

    # Grid height: 3 + 8*6 = 51.
    for r in range(3, GRID_WEEK_START_ROW + WEEK_HEIGHT * MAX_WEEKS):
        ws.row_dimensions[r].height = 18

    header = title or f"{calendar.month_name[month]} {year}"
    ws.merge_cells(start_row=1, start_column=2, end_row=1, end_column=22)
    c = ws.cell(1, 2, header)
    c.font = FONT_HEADER
    c.alignment = ALIGN_CENTER

    days_in_month = calendar.monthrange(year, month)[1]

    # Choose 5-week or 6-week calendar grid based on the month layout (Sunday-start weeks)
    first_grid_day = date(year, month, 1)
    offset = weekday_sun0(first_grid_day)
    weeks_needed = (offset + days_in_month + 6) // 7
    grid_weeks = 6 if weeks_needed > 5 else 5

    for week_index in range(grid_weeks):
        R = GRID_WEEK_START_ROW + WEEK_HEIGHT * week_index
        for dow in range(7):
            col_start = SUN_START_COL + DAY_WIDTH * dow
            col_mid = col_start + 1
            col_end = col_start + 2

            cell_idx = week_index * 7 + dow
            daynum = cell_idx - offset + 1
            in_month = 1 <= daynum <= days_in_month

            fill_hex = None
            if not in_month:
                fill_hex = NONMONTH_FILL
            else:
                d = date(year, month, daynum)
                if is_sunday(d):
                    fill_hex = SUNDAY_FILL

            fill = PatternFill("solid", fgColor=fill_hex) if fill_hex else None

            for rr in range(R, R + WEEK_HEIGHT):
                for cc in range(col_start, col_start + DAY_WIDTH):
                    cell = ws.cell(rr, cc)
                    cell.font = FONT_MAIN
                    cell.alignment = ALIGN_CENTER
                    if fill:
                        cell.fill = fill

            if not in_month:
                continue

            d = date(year, month, daynum)
            ws.cell(R, col_end, daynum).font = FONT_MAIN
            ws.cell(R, col_end).alignment = Alignment(horizontal="right", vertical="top")

            ws.cell(R + 1, col_start, "PN-").font = FONT_MAIN
            ws.cell(R + 2, col_start, "AN-").font = FONT_MAIN
            if is_weekday(d):
                ws.cell(R + 3, col_start, "W-").font = FONT_MAIN

            roles = schedule.get(d.isoformat(), {})

            def put_name(row_off: int, role_key: str):
                name = roles.get(role_key, "")
                ws.cell(R + row_off, col_mid, name).font = FONT_MAIN

            put_name(1, "PN")
            if not is_sunday(d):
                put_name(2, "AN")
            if is_weekday(d):
                put_name(3, "W")
            put_name(4, "BU1")
            put_name(5, "BU2")
            put_name(6, "BU3")
            put_name(7, "BU4")

            if d in observed_holidays:
                for off in range(1, 8):
                    ws.cell(R + off, col_start, "").value = ""
                    ws.cell(R + off, col_mid, "").value = ""
                ws.merge_cells(start_row=R, start_column=col_start, end_row=R + 7, end_column=col_end)
                ws.cell(R, col_start, "HOLIDAY").alignment = ALIGN_CENTER
                ws.cell(R, col_start).font = Font(name="Calibri", size=14, bold=True)

    # Summary tab
    ws2 = wb.create_sheet("Summary")
    ws2.sheet_view.showGridLines = False
    ws2["A1"] = f"Summary: {calendar.month_name[month]} {year}"
    ws2["A1"].font = Font(name="Calibri", size=14, bold=True)

    roles_to_count = ["PN", "AN", "W", "BU1", "BU2", "BU3", "BU4"]
    ws2["A3"] = "Name"
    for j, r in enumerate(roles_to_count, start=2):
        ws2.cell(3, j, r)
    ws2.cell(3, len(roles_to_count) + 2, "Total Assignments")
    ws2.cell(3, len(roles_to_count) + 3, "Total Hours")

    counts = {n: {r: 0 for r in roles_to_count} for n in roster}
    hours = {n: 0 for n in roster}
    for ds, roles in schedule.items():
        d = datetime.strptime(ds, "%Y-%m-%d").date()
        for r, n in roles.items():
            if n not in counts:
                continue
            if r in counts[n]:
                counts[n][r] += 1
            hours[n] += hours_for_role(d, r, observed_holidays)

    for i, n in enumerate(roster, start=4):
        ws2.cell(i, 1, n)
        tot = 0
        for j, r in enumerate(roles_to_count, start=2):
            v = counts[n][r]
            ws2.cell(i, j, v)
            tot += v
        ws2.cell(i, len(roles_to_count) + 2, tot)
        ws2.cell(i, len(roles_to_count) + 3, hours[n])

    ws2.column_dimensions["A"].width = 14
    for col in range(2, len(roles_to_count) + 4):
        ws2.column_dimensions[get_column_letter(col)].width = 14

    # Weekly Hours tab (Sun–Sat)
    ws3 = wb.create_sheet("Weekly Hours")
    ws3.sheet_view.showGridLines = False
    ws3["A1"] = f"Weekly Hours (Sun–Sat): {calendar.month_name[month]} {year}"
    ws3["A1"].font = Font(name="Calibri", size=14, bold=True)

    ws3["A3"] = "Week Start (Sun)"
    ws3["A3"].font = Font(name="Calibri", size=11, bold=True)
    for j, name in enumerate(roster, start=2):
        cell = ws3.cell(3, j, name)
        cell.font = Font(name="Calibri", size=11, bold=True)
        cell.alignment = ALIGN_CENTER

    first_day = date(year, month, 1)
    last_day = date(year, month, calendar.monthrange(year, month)[1])
    week_starts = sorted({week_start_sun(d) for d in month_days(year, month)})

    def hours_on_day(dd: date, person: str) -> int:
        if dd in observed_holidays:
            return 0
        if dd.month == month and dd.year == year:
            roles = schedule.get(dd.isoformat(), {})
        elif dd < first_day and prev_sched:
            roles = prev_sched.get(dd.isoformat(), {})
        else:
            roles = {}
        day_hours = 0
        for rr, nn in roles.items():
            if nn == person:
                day_hours = max(day_hours, hours_for_role(dd, rr, observed_holidays))
        return day_hours

    red_fill = PatternFill("solid", fgColor="FFC7CE")
    row = 4
    for wsun in week_starts:
        ws3.cell(row, 1, wsun.isoformat()).alignment = ALIGN_CENTER
        for j, person in enumerate(roster, start=2):
            tot = 0
            for i in range(7):
                dd = wsun + timedelta(days=i)
                if dd > last_day:
                    continue
                tot += hours_on_day(dd, person)
            c = ws3.cell(row, j, tot)
            c.alignment = ALIGN_CENTER
            if tot > 40:
                c.fill = red_fill
        row += 1

    ws3.column_dimensions["A"].width = 16
    for col in range(2, 2 + len(roster)):
        ws3.column_dimensions[get_column_letter(col)].width = 12

    # Pay Period Hours tab
    if payperiods:
        ws4 = wb.create_sheet("Pay Period Hours")
        ws4.sheet_view.showGridLines = False
        ws4["A1"] = f"Pay Period Hours (Cap 80): {calendar.month_name[month]} {year}"
        ws4["A1"].font = Font(name="Calibri", size=14, bold=True)

        ws4["A3"] = "Pay Period"
        ws4["B3"] = "Start"
        ws4["C3"] = "End"

        for j, name in enumerate(roster, start=4):
            ws4.cell(3, j, name).font = Font(name="Calibri", size=11, bold=True)
            ws4.cell(3, j).alignment = ALIGN_CENTER

        first_day = date(year, month, 1)

        def pp_hours(person: str, pp: Tuple[date, date]) -> int:
            s, e = pp
            tot = 0
            dd = s
            while dd <= e:
                if dd.month == month and dd.year == year:
                    roles = schedule.get(dd.isoformat(), {})
                elif dd < first_day and prev_sched:
                    roles = prev_sched.get(dd.isoformat(), {})
                else:
                    roles = {}
                day_hours = 0
                for rr, nn in roles.items():
                    if nn == person:
                        hols = observed_holidays if dd.year == year else observed_holidays_for_year(dd.year)
                        day_hours = max(day_hours, hours_for_role(dd, rr, hols))
                tot += day_hours
                dd += timedelta(days=1)
            return tot

        row = 4
        for idx_pp, (s, e) in enumerate(payperiods, start=1):
            ws4.cell(row, 1, f"PP{idx_pp}")
            ws4.cell(row, 2, s.isoformat())
            ws4.cell(row, 3, e.isoformat())
            for j, person in enumerate(roster, start=4):
                tot = pp_hours(person, (s, e))
                c = ws4.cell(row, j, tot)
                c.alignment = ALIGN_CENTER
                if tot > 80:
                    c.fill = red_fill
            row += 1

        for col in range(1, 4 + len(roster)):
            ws4.column_dimensions[get_column_letter(col)].width = 14

    # Fairness / quota violations tab (optional)
    if fairness_report is not None:
        add_violations_sheet(wb, fairness_report)

    wb.save(out_xlsx)


# ------------------------------
# Fairness reporting (PN/AN/W)
# ------------------------------
def compute_primary_actuals(schedule: Dict[str, Dict[str, str]], roster: List[str]) -> Dict[str, Dict[str, int]]:
    roles = ("PN", "AN", "W")
    out: Dict[str, Dict[str, int]] = {r: {n: 0 for n in roster} for r in roles}
    for _, rm in schedule.items():
        for r in roles:
            n = rm.get(r)
            if n in out[r]:
                out[r][n] += 1
    return out

def build_fairness_report(
    year: int,
    month: int,
    roster: List[str],
    sales_order: List[str],
    schedule: Dict[str, Dict[str, str]],
    observed_holidays: Set[date],
) -> Dict:
    days = month_days(year, month)
    push_days = push_days_for_month(year, month)
    targets = compute_primary_targets(days, push_days, roster, sales_order, observed_holidays)
    actual = compute_primary_actuals(schedule, roster)

    deltas: Dict[str, Dict[str, int]] = {r: {} for r in ("PN", "AN", "W")}
    max_dev = 0
    sum_dev = 0
    rows = []

    for r in ("PN", "AN", "W"):
        for n in roster:
            t = targets.get(r, {}).get(n, 0)
            a = actual.get(r, {}).get(n, 0)
            d = a - t
            deltas[r][n] = d
            max_dev = max(max_dev, abs(d))
            sum_dev += abs(d)
            rows.append({"role": r, "name": n, "target": int(t), "actual": int(a), "delta": int(d)})

    return {
        "month": f"{year}-{month:02d}",
        "roster": roster,
        "sales_order": sales_order,
        "targets": targets,
        "actual": actual,
        "deltas": deltas,
        "max_deviation": int(max_dev),
        "sum_abs_deviation": int(sum_dev),
        "rows": rows,
    }

def add_violations_sheet(wb: openpyxl.Workbook, report: Dict):
    ws = wb.create_sheet("Violations")
    ws.sheet_view.showGridLines = False

    ws["A1"] = f"Fairness / Quota Violations (PN/AN/W) — {report.get('month','')}"
    ws["A1"].font = Font(name="Calibri", size=14, bold=True)

    ws["A3"] = "Max deviation"
    ws["B3"] = report.get("max_deviation", "")
    ws["A4"] = "Sum abs deviation"
    ws["B4"] = report.get("sum_abs_deviation", "")

    headers = ["Role", "Name", "Target", "Actual", "Delta"]
    for j, h in enumerate(headers, start=1):
        c = ws.cell(6, j, h)
        c.font = Font(name="Calibri", size=11, bold=True)
        c.alignment = ALIGN_CENTER

    red_fill = PatternFill("solid", fgColor="FFC7CE")
    row = 7
    for rec in report.get("rows", []):
        ws.cell(row, 1, rec["role"]).alignment = ALIGN_CENTER
        ws.cell(row, 2, rec["name"]).alignment = ALIGN_CENTER
        ws.cell(row, 3, rec["target"]).alignment = ALIGN_CENTER
        ws.cell(row, 4, rec["actual"]).alignment = ALIGN_CENTER
        dcell = ws.cell(row, 5, rec["delta"])
        dcell.alignment = ALIGN_CENTER
        if rec["delta"] != 0:
            dcell.fill = red_fill
        row += 1

    ws.column_dimensions["A"].width = 10
    ws.column_dimensions["B"].width = 14
    ws.column_dimensions["C"].width = 10
    ws.column_dimensions["D"].width = 10
    ws.column_dimensions["E"].width = 10


# ------------------------------
# Main
# ------------------------------
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--month", required=True, help="YYYY-MM, e.g. 2026-02")
    ap.add_argument("--timeoff-xlsx", required=True)
    ap.add_argument("--timeoff-sheet", required=True)
    ap.add_argument("--prev-schedule", required=True, help="Previous month schedule JSON (exported from Excel)")
    ap.add_argument("--sales-sheet", default="Sales Ranking")
    ap.add_argument("--out-json", default=None)
    ap.add_argument("--out-xlsx", default=None)
    ap.add_argument("--out-violations", default=None, help="Optional output path for fairness/violations JSON")
    ap.add_argument("--seed", type=int, default=11)
    ap.add_argument("--roster-json", default=None, help="Optional JSON file with roster list (overrides DEFAULT_ROSTER / Sales Ranking)")
    ap.add_argument("--payperiods-json", default=None, help="Optional JSON file with pay period boundaries (for 80h cap + audit)")
    ap.add_argument("--payperiod-anchor-start", default="2026-01-25", help="Sunday-start anchor (YYYY-MM-DD) for repeating bi-weekly pay periods")
    args = ap.parse_args()

    year, month = parse_month_arg(args.month)
    roster = load_roster_from_json(args.roster_json) if args.roster_json else DEFAULT_ROSTER[:]

    timeoff = load_timeoff_from_xlsx(args.timeoff_xlsx, args.timeoff_sheet)
    cons = compile_constraints(timeoff)

    sales_order = load_sales_ranking_from_timeoff_xlsx(
        xlsx_path=args.timeoff_xlsx,
        sheet_name=args.sales_sheet,
        year=year,
        month=month,
        roster_names=roster,
    )

    prev = load_schedule_json(args.prev_schedule)

    cfg = BuildConfig(year=year, month=month, roster=roster, sales_order=sales_order, rng_seed=args.seed)

    if args.payperiods_json:
        payperiods = load_payperiods_from_json(args.payperiods_json)
    else:
        month_start = date(year, month, 1)
        month_end = date(year, month, calendar.monthrange(year, month)[1])
        anchor = datetime.strptime(args.payperiod_anchor_start, "%Y-%m-%d").date()

        raw_periods = generate_payperiods(
            anchor,
            month_start - timedelta(days=28),
            month_end + timedelta(days=28)
        )

        # Keep periods that overlap with the current month
        payperiods = []
        for s, e in raw_periods:
            if s <= month_end and e >= month_start:
                payperiods.append((s, e))

    sched = build_schedule(cfg, prev, cons, payperiods)
    fairness_report = build_fairness_report(year, month, roster, sales_order, sched, observed_holidays_for_year(year))

    out_json = args.out_json or str(Path(args.prev_schedule).with_name(f"{year}_{month:02d}_schedule.json"))
    out_xlsx = args.out_xlsx or str(Path(args.prev_schedule).with_name(f"{calendar.month_name[month]}_{year}_Schedule.xlsx"))
    out_vio = args.out_violations or str(Path(args.prev_schedule).with_name(f"{year}_{month:02d}_violations.json"))

    Path(out_json).write_text(json.dumps(sched, indent=2), encoding="utf-8")
    Path(out_vio).write_text(json.dumps(fairness_report, indent=2), encoding="utf-8")

    print(f"✅ Wrote schedule JSON → {out_json}")
    print(f"✅ Wrote fairness/violations JSON → {out_vio}")

    export_schedule_to_excel(
        sched,
        year,
        month,
        out_xlsx,
        roster,
        observed_holidays_for_year(year),
        prev,
        payperiods,
        fairness_report=fairness_report,
    )
    print(f"✅ Wrote schedule Excel → {out_xlsx}")

if __name__ == "__main__":
    main()
